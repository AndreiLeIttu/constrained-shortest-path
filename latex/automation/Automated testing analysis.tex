\documentclass{article}
\usepackage{graphicx}

\title{Testing analysis}
\author{Andrei Ionita}

\begin{document}
\maketitle

\section{Introduction and methodology}
This document provides the results and observations that I came across after using automated testing to test 
a minizinc model that uses dpath to find the shortest road between two given nodes, with additional mandatory vertex
constraints.


I implemented a python script to randomly generate numbers that would be used to make up a .dzn file, that would be used
as the input to the minizinc model. Afterwards, I created a bash script that would continuously run the python script and then
run the minizinc model on the provided, generated input. The limits I used for the bash script were the following:
\begin{enumerate}
    \item A single run of the model has an upper limit of 30 sec before it is terminated.
    \item The bash script repeats the process until 50 successful tests are generated.
\end{enumerate}
The output of the minizinc model was then appended to a different .txt file together with all the other results.
That file is what I used to analyse the model. Of course, the statistics are not based on only 50 successful runs of 
the model, that was just the number that I chose to represent a single batch of tests.

\section{Types of input and their respective statistics}
After a couple of tries using graphs with no more than 100 nodes and/or edges, and seeing that none of the inputs required
30 seconds of runtime, I decided to separate the testing and analysis into two parts: 
\begin{enumerate}
    \item Graphs with less than or equal to 100 nodes and edges(from this point onwards called small graphs).
    \item Graphs with more than 100 nodes/edges, and less than 1000 nodes and edges(from this point onwards called large graphs).
\end{enumerate}
The following sections will demonstrate my findings for both of these categories of inputs.


\subsection{Small Graphs}
Small note to begin with: The runtime for \textbf{all} of the tests was 0 ms. 

Given this observation, the only conclusions I can
draw are unrelated to time. An interesting and, at the same time, obvious finding is the fact that using \texttt{bounded\_path} 
instead of \texttt{bounded\_dpath} had a greater rate of success ('success' meaning that the model found a road that meets the constraints): 
$~40\%$ of the generated inputs had solutions for undirected graphs, while only around $25\%$ of generated inputs had solutions using the 
dpath algorithm. (directed graphs) Given the nature of directed and undirected graphs, this result was somewhat to be expected, since there 
overall less roads between any two nodes in a directed graph than in an undirected one with the same edges. 

However, the disadvantage of using \texttt{bounded\_path} was the runtime itself. Compared to the 0 ms, instant runtime in the case of directed 
graphs, each run of the model took on average 7 seconds when using undirected graphs, most likely due to the sheer amount of possible roads. 
Therefore, automated testing was easier from the point of view of time spent in the case of the final algorithm - \texttt{bounded\_dpath}.

Below, I plotted 4 batches of tests, so 200 successful model runs. More specifically, the following figure shows the types of 
graphs generated by the python script. Even given the fact that the generation is entirely random, I thought the results can be interesting.

\begin{figure}[h]
    \centering 
    \includegraphics[width=0.8\linewidth]{../images/figure1.png}
    \caption{Figure showing distribution of graph types generated with a solution found by the model}
\end{figure}

To be precise, out of 200 random successful tests, 180 of them represent a sparse graph(less than half of possible edges), while only 20
of them represent dense graphs. While one would expect dense graphs to have a higher runtime, due to the low nature of the number of nodes 
and edges, as mentioned previously, the runtime was still always 0 ms. 
\subsection{Large Graphs} 
After playing around with small values (under 100) of edges and nodes, and seeing that the model had no problem 
finding a solution with respect to the constraints almost instantly, I decided to try testing the limits of the model's speed through higher values.

\end{document} 